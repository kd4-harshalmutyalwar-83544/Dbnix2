import { Select as AntSelect, FormControl, InputLabel, Menu, MenuItem, Button, TextField } from '@mui/material';
import { Col, InputNumber, Modal, Row, Slider, Select, Input, DatePicker } from 'antd';
import React, { useCallback, useContext, useEffect, useState } from 'react';
import { ToastContainer, toast } from 'react-toastify';
import Statecontext from '../screens/Statecontext';
import moment from 'moment/moment';
import axios from 'axios';
import * as XLSX from 'xlsx';
import Papa from 'papaparse';
import { ThreeDots } from 'react-loader-spinner';
import CheckboxComponent from '../screens/CheckboxComponent';
import TableFile from '../screens/Table';
import './FileModal1.css';
// import Stack from '@mui/material/Stack';
import Stack from '@mui/material/Stack';
import Pagination from '@mui/material/Pagination';
import Box from '@mui/material/Box';
import LinearProgress from '@mui/material/LinearProgress';
import { IoMdClose } from 'react-icons/io';
import { ArrowDropDownIcon } from '@mui/x-date-pickers';








const { RangePicker } = DatePicker;

const FileModal1 = () =>  {
     
        // const [pdata, setPdata] = useState([{}]);      
  const { fileNameToSend,apiBaseUrl, setLogoutTimers, folderName, userSubResult, checkedColumns, setCheckedColumns } = useContext(Statecontext);
        const [fullDataToDownloadLoader, setFullDataToDownloadLoader] = useState(false);
        const [datefromfile,setDatefomFile] = useState(null);
        const [maxRowsPerSheet, setMaxRowsPerSheet] = useState(700000);
        const [startDateTable, setStartDate] = useState(null);
        const [pageWithDate, setPageWithDate] = useState(false);
        const [searchPdata, setSearchPdata] = useState([{}]);
        const [accessGranted, setAccessGranted] = useState(true);
        const [file_modal_Loader, setFile_modal_Loader] = useState(false);
        const [noDataError, setNoDataError] = useState(false);
        const [searchTerm, setSearchTerm] = useState('');
        const [noData, setNoData] = useState(false);
        const [dateFromFile, setDateFromFile] = useState(null);
        const [OPTIONS, setOPTIONS] = useState([]);
        const [columnOPTIONS, setColumnOPTIONS] = useState([]);
        const [searchTextForFilter, setSearchTextForFilter] = useState('');
        const [page, setPage] = useState(1);
        const [numRows, setNumRows] = useState(1);
        const [endDateTable, setEndDate] = useState(null);
        const [isChecked, setIsChecked] = useState(false);
        const [selectedItems, setSelectedItems] = useState();
        const [valueSearchText, setValueSearchText] = useState('');
        const [selectedSearchColumn, setSelectedSearchColumn] = useState('');
        const [dropdownSelectedColumn, setDropdownSelectedColumn] = useState('');
        const [isSubmitting, setIsSubmitting] = useState(false);
        const [fileDownloadRequest, setFileDownloadRequest] = useState(null);
        const userId = sessionStorage.getItem('userId');
        const [cancelTokenSource, setCancelTokenSource] = useState(null);
        const [inputValue, setInputValue] = useState(700000);
        const [anchorEl, setAnchorEl] = useState(null);
        const [isOpen, setIsOpen] = useState(false);
        const [showConsentForm, setShowConsentForm] = useState(false);
        const [columns, setColumns] = useState([]);
        const [subMenuAnchorEl, setSubMenuAnchorEl] = useState(null);
        const [currentSubMenu, setCurrentSubMenu] = useState('');
        const [downloadFileName, setDownloadFileName] = useState();
        const [subMenuAnchorEl2, setSubMenuAnchorEl2] = useState(null);

        const userRole = sessionStorage.getItem("userRole") || "";
        const pageSize = 100;
        const userDownload = sessionStorage.getItem("userDownload")


        const from = moment(datefromfile);


      const onChange = (newValue) => {
    if (newValue < 0) {
      setInputValue(1);
    } else {
      setInputValue(newValue);
    }
  };

        const handleClick = (event) => {
    setAnchorEl(event.currentTarget);
  };
         const handleClose = () => {
    setAnchorEl(null);
    setSubMenuAnchorEl(null);
    setCurrentSubMenu('');
  };

   const handleSubMenuClick = (event, subMenu) => {
    setCurrentSubMenu(subMenu);
    setSubMenuAnchorEl(event.currentTarget);
  };

  const handleSubMenuClick2 = (event) => {
    setSubMenuAnchorEl2(event.currentTarget);
  };


   const handleToggle = () => {
    setIsOpen(!isOpen);
  };

      const disableDate = (current) => {
        if (userRole === 'User ') {
            if (from) {
                const minDate = from.clone().add(-3, 'days');
                return (
                    current.isAfter(from, "day") || 
                    current.isBefore(minDate, "day")

                    );
            }
        } else {
            return current.isAfter(from, "day");
        }
        return false;
    };

    const handleCheckboxClick = (e) => {
    // Optional: prevent event propagation if needed
  };

  const handleConsentFormClose = () => {
    setShowConsentForm(false);
    setFileDownloadRequest(null);
    setIsChecked(false);
  };

   const handleConsentBoxChange = (e) => {
    setIsChecked(e.target.checked);
  };



  const handleDateChange = (dates) => {
         if (dates && dates.length >= 2) {

      const [day, month, year] = datefromfile.split('/').map(Number);
      
      const formatted_Date = new Date(year, month - 1, day);
      const maxBusinessDateStr = formatted_Date;
      const maxBusinessDate = new Date(Date.parse(maxBusinessDateStr));

      const startDateLimit = new Date(maxBusinessDate);
      startDateLimit.setDate(startDateLimit.getDate() - 4);

      const endDateLimit = new Date(maxBusinessDate);
      endDateLimit.setDate(endDateLimit.getDate() + 1);

      let sdate = new Date(dates[0]);
      sdate.setDate(sdate.getDate() + 1);

      let edate = new Date(dates[1]);
      edate.setDate(edate.getDate() + 1);

      if (userRole === 'User') {
        if (edate > endDateLimit) {
          toast.error("End Date is Out of Permitted Range...", { theme: "colored" });
          setPageWithDate(false);
        } 
        else if (sdate < startDateLimit) {
          toast.error("Start Date is Out of Permitted Range...", { theme: "colored" });
          setPageWithDate(false);
        } 
        else {
          setStartDate(sdate.toISOString().split('T')[0]);
          fetchContentInFilesWithDate(fileNameToSend, page, sdate.toISOString().split('T')[0], edate.toISOString().split('T')[0]);
        }
      } 
      else {
        setStartDate(sdate.toISOString().split('T')[0]);
        fetchContentInFilesWithDate(fileNameToSend, page, sdate.toISOString().split('T')[0], edate.toISOString().split('T')[0]);
      }
      setEndDate(edate ? edate.toISOString().split('T')[0] : '');
    } else {
      setStartDate(null);
      setEndDate(null);
      setPageWithDate(false);
    }
  };

  
  const cleanupAfterCancel = () => {
    setCancelTokenSource(null);
    setFullDataToDownloadLoader(false);
  };

  const cancelDownload = () => {
    if (cancelTokenSource) {
      cancelTokenSource.cancel('Download canceled');
      sessionStorage.setItem("process", false);
      cleanupAfterCancel();
    }
  };


  const fetchContentInFiles = async (e, newPage) => {

    setFile_modal_Loader(true);

    if (valueSearchText.trim() !== '') {
      handleSearchText(newPage, selectedSearchColumn, valueSearchText)
    } else {

      try {
        const getContentInFilesApiUrl = `${apiBaseUrl}api/ReportModules/getModalData`;
        const urlForApi = getContentInFilesApiUrl;
        const filesResponse = await axios.post(urlForApi, 
          {
            username: userId,
            folderName: folderName,
            filename: e,
            ColumnName: checkedColumns.length > 0 ? checkedColumns : ["*"],
            pageSize: pageSize,
            pageNo: newPage,
          }, 
          { withCredentials: true,
            headers : {
              Authorization : `Bearer ${sessionStorage.getItem("token")}`
            },
           });

           if(filesResponse.headers['X-New-JWT-Token']){
            sessionStorage.setItem("token", filesResponse.headers['X-New-JWT-Token'])
           }

        if (filesResponse.data === "You don't have access to this data") {
          setAccessGranted(false);
          setFile_modal_Loader(false);
        } 
        else if (filesResponse.data === "No Data Found" || filesResponse.data.totalCount === 0) {
          setNoData(true);
          setAccessGranted(false);
          setFile_modal_Loader(false);
        } else {
          
          const pro = filesResponse.data.data;
          setPdata(pro);
          setSearchPdata(pro);
          const convertedArray = Object.keys(pro[0]).map(item => ({
            value: item,
            label:item,
          }));
          setOPTIONS(convertedArray)
          setColumnOPTIONS(convertedArray)
          setSearchPdata(pro);
          setNumRows(filesResponse.data.totalCount);
          setAccessGranted(true);
          setPage(newPage);
          setFile_modal_Loader(false);
        }
      } catch (error) {
        setPageWithDate(false);
        if (error.response && (error.response.status === 404 || error.response.status === 500)) {
          setNoData(true);
          setAccessGranted(false);
          setNoDataError(true);
        }

        if(error.response.status === 401) {
          if(error.response.data === 'Unauthorized: Token is expired') {
            toast.error("Session expired", {theme: "colored"})
          } else {
            toast.error("Already open in another Tab", {theme : "colored"});
          }
          sessionStorage.clear(); setTimeout(() => {
            window.location.href = "/";
          }, 1000);
        }
        console.error("Error fetching files:", error);
        setFile_modal_Loader(false);
      }
    }
  };


  const fetchContentInFilesWithDate = async (e, newPage, start , end) => {

    setFile_modal_Loader(true);

    if (valueSearchText !== '') {
      handleSearchText(newPage, selectedSearchColumn, valueSearchText)
    } else {

      try {
        const getContentInFilesApiUrl = `${apiBaseUrl}api/ReportModules/getModalDataWithDate`;
        const urlForApi = getContentInFilesApiUrl
        const filesResponse = await axios.post(urlForApi, 
          {
            username: userId,
            filename: fileNameToSend,
            foldername: folderName,
            checkedColumnName: checkedColumns.length > 0 ? checkedColumns : ["*"],
            pagesize: pageSize,
            pagenumber: newPage,
            startDate: start,
            endDate: end,
          }, 
          { withCredentials: true,
            headers : {
              Authorization : `Bearer ${sessionStorage.getItem("token")}`
            },
           });

           if(filesResponse.headers['X-New-JWT-Token']){
            sessionStorage.setItem("token", filesResponse.headers['X-New-JWT-Token'])
           }

        if (filesResponse.data === "You don't have access to this data") {
          setAccessGranted(false);
          setFile_modal_Loader(false);
          setPageWithDate(false);
        } 
        else if (filesResponse.data === "No Data Found" || filesResponse.data.totalCount === 0) {
          setNoData(true);
          setAccessGranted(false);
          setFile_modal_Loader(false);
          setPageWithDate(false);
        } else {
          setPageWithDate(true);
          const pro = filesResponse.data.data;
          setPdata(pro);
          setSearchPdata(pro);
          setNumRows(filesResponse.data.totalCount);
          setAccessGranted(true);
          setPage(newPage);
          setFile_modal_Loader(false);
        }
      } catch (error) {
        setPageWithDate(false);
        if (error.response && (error.response.status === 404 || error.response.status === 500)) {
          setNoData(true);
          setAccessGranted(false);
          setNoDataError(true);
        }

        if(error.response.status === 401) {
          if(error.response.data === 'Unauthorized: Token is expired') {
            toast.error("Session expired", {theme: "colored"})
          } else {
            toast.error("Already open in another Tab", {theme : "colored"});
          }
          sessionStorage.clear(); setTimeout(() => {
            window.location.href = "/";
          }, 1000);
        }
        console.error("Error fetching files:", error);
        setFile_modal_Loader(false);
      }
    }
  };


  useEffect(() => {
    fetchColumns();
  }, []);

  useEffect(() =>{}, [setSearchTerm])

  useEffect(() => {
    // Responsive note: This effect will refresh data on changes. You may consider debouncing heavy API calls.
    fetchContentInFiles(fileNameToSend, page);
    fetchMaxDate();
  }, [searchTextForFilter,
    setValueSearchText,
    setSearchTextForFilter,
    checkedColumns,
    setSelectedSearchColumn,
    setInputValue
  ]);

  const handleChange = (event, value) => {
    if (checkedColumns.length > 0) {
      fetchByColumnName(fileNameToSend, value);
    } else if (pageWithDate === false) {
      fetchContentInFiles(fileNameToSend, value);
    } else {
      fetchContentInFilesWithDate(fileNameToSend, value, startDateTable, endDateTable);
    }
  };

  const getFullFileData = async (filename, fileTypes) => {
    const source = axios.CancelToken.source();
    setCancelTokenSource(source);
    setFullDataToDownloadLoader(true);
    setLogoutTimers(30);
    sessionStorage.setItem("process", true);
    var getFullData = `${apiBaseUrl}api/ReportModules/`;

    try {
      if (valueSearchText !== '') {
        getFullData += 'GenerateFullFileDataFromTableAfterFilter';
        const filesResponse = await axios.post(getFullData, {
          username: userId,
          filename: filename,
          foldername: folderName,
          checkedColumns: checkedColumns.length > 0 ? checkedColumns : ["*"],
          searchColumn: selectedSearchColumn,
          searchValue: valueSearchText,
          startDate: startDateTable,
          endDate: endDateTable,
          fileFormat: fileTypes,
          maxRowsPerSheet: maxRowsPerSheet,
        }, {
          withCredentials: true,
          headers : {
              Authorization : `Bearer ${sessionStorage.getItem("token")}`
            },
          responseType: 'blob',
          cancelToken: source.token,
        });
        
        if(filesResponse.headers['X-New-JWT-Token']){
            sessionStorage.setItem("token", filesResponse.headers['X-New-JWT-Token'])
           }

        if (filesResponse.status === 200) {
          const blob = new Blob([filesResponse.data], { type: filesResponse.headers['content-type'] });
          const url = window.URL.createObjectURL(blob);
          const link = document.createElement('a');
          link.href = url;
          link.setAttribute('download', `${downloadFileName}.zip`);
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);
          setLogoutTimers(5);
          setFullDataToDownloadLoader(false);
          toast.success("Download successfully...", { theme: "colored" });
        } else {
          setFullDataToDownloadLoader(false);
          setLogoutTimers(5);
          toast.error("Something went wrong...", { theme: "colored" });
        }
      } else {
        const fullData = getFullData + `GetAlldataAndGenerateFile`;
        const filesResponse = await axios.post(fullData, {
          "checkedColumns": checkedColumns.length > 0 ? checkedColumns : ["*"],
          "endDate": endDateTable,
          "fileFormat": fileTypes,
          "filename": filename,
          "foldername": folderName,
          "maxRowsPerSheet": maxRowsPerSheet,
          "startDate": startDateTable,
          "username": userId,
        }, {
          headers: {
            'Content-Type': 'application/json',
          },
          withCredentials: true,
          headers : {
              Authorization : `Bearer ${sessionStorage.getItem("token")}`
            },
          responseType: 'blob',
          cancelToken: source.token,
        });

        if (filesResponse.status === 200) {    
          const blob = new Blob([filesResponse.data], { type: filesResponse.headers['content-type'] });
          const url = window.URL.createObjectURL(blob);
          const link = document.createElement('a');
          link.href = url;
          link.setAttribute('download', `${downloadFileName}.zip`);
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);
          setLogoutTimers(5);
          setFullDataToDownloadLoader(false);
          toast.success("Download successfully...", { theme: "colored" });
        } else {
          setFullDataToDownloadLoader(false);
          setLogoutTimers(5);
          toast.error("Something went wrong...", { theme: "colored" });
        }
      }
    } catch (error) {
      console.error("error=:", error);
      if (axios.isCancel(error)) {
        setLogoutTimers(5);
        setFullDataToDownloadLoader(false);
      } else {
        console.error("Error fetching files in the folder:", error);
        toast.error("Something went wrong...", { theme: "colored" });
        setLogoutTimers(5);
        setFullDataToDownloadLoader(false);
      }
      setLogoutTimers(5);
      setFullDataToDownloadLoader(false);

      if(error.response.status === 401) {
          if(error.response.data === 'Unauthorized: Token is expired') {
            toast.error("Session expired", {theme: "colored"})
          } else {
            toast.error("Already open in another Tab", {theme : "colored"});
          }
          sessionStorage.clear(); setTimeout(() => {
            window.location.href = "/";
          }, 1000);
        }
    } finally {
      sessionStorage.setItem("process", false);
    }
  };



  const consentUpdate = async () => {
    const consentDetails = {
      "Username": userId,
      "Folder": folderName,
      "file": fileNameToSend,
      "type": fileDownloadRequest,
    };

    try {
      const apiToFetch = `${apiBaseUrl}api/UsersLogs/InsertConsentDetails`;
      const response = await axios.post(apiToFetch, consentDetails, {
        withCredentials: true,
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${sessionStorage.getItem("token")}`
        },
      });

      if(response.headers["X-New-JWT-Token"]){
        sessionStorage.setItem("token", response.headers['X-New-JWT-Token'])
      }
      if (response.status === 200) {
        console.error("API ERROR", response);
      }
    } catch (error) {

      if(error.response.status === 401) {
          if(error.response.data === 'Unauthorized: Token is expired') {
            toast.error("Session expired", {theme: "colored"})
          } else {
            toast.error("Already open in another Tab", {theme : "colored"});
          }
          sessionStorage.clear(); setTimeout(() => {
            window.location.href = "/";
          }, 1000);
        }
      console.error("The API error is", error);
    }
  };


  const handleConsentFormSubmit = async () => {
    if (fileDownloadRequest) {
      consentUpdate();
      await performFileDownload(fileDownloadRequest);
      handleConsentFormClose();
    }
  };

    const handleFileDownload = (type) => {
    handleClose();
    setFileDownloadRequest(type);
    setShowConsentForm(true);
    if (startDateTable !== null && endDateTable !== null) {
      setDownloadFileName(fileNameToSend + '(' + startDateTable.toString() + '_' + endDateTable.toString() + ')');
    } else {
      setDownloadFileName(fileNameToSend + '(' + datefromfile.toString() + ')');
    }
  };

  const performFileDownload = async (e) => {
    // Log user action (userLogs call)
    userLogs();
    sessionStorage.setItem("process", true);
    setFullDataToDownloadLoader(true);

    try {
      if (e.startsWith('F')) {
        if (e === 'Fxlsx') {
          await getFullFileData(fileNameToSend, 'xlsx');
        } else if (e === 'Fcsv') {
          await getFullFileData(fileNameToSend, 'csv');
        } else if (e === 'Fhtxt') {
          await getFullFileData(fileNameToSend, 'htxt');
        } else if (e === 'Ftxt') {
          await getFullFileData(fileNameToSend, 'txt');
        }
      } else {
        if (e === 'Cxlsx') {
          const ws = XLSX.utils.json_to_sheet(pdata);
          const wb = XLSX.utils.book_new();
          XLSX.utils.book_append_sheet(wb, ws, 'Sheet1');
          XLSX.writeFile(wb, `${downloadFileName}.xlsx`);
        } else if (e === 'Ccsv') {
          const csv = Papa.unparse(pdata);
          const blob = new Blob([csv], { type: 'text/csv' });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = `${downloadFileName}.csv`;
          a.click();
          URL.revokeObjectURL(url);
        } else if (e === 'Chtxt') {
          const tabSeparatedContent = convertToText(pdata);
          const blob = new Blob([tabSeparatedContent], { type: 'text/plain' });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = `${downloadFileName}.txt`;
          a.click();
          URL.revokeObjectURL(url);
        } else if (e === 'Ctxt') {
          const tabSeparatedContent = convertToTextWithoutHeader(pdata);
          const blob = new Blob([tabSeparatedContent], { type: 'text/plain' });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = `${downloadFileName}.txt`;
          a.click();
          URL.revokeObjectURL(url);
        }
      }
    } catch (error) {
      console.error("Error:", error);
    } finally {
      setFullDataToDownloadLoader(false);
      setIsChecked(false);
      sessionStorage.setItem("process", false);
    }
    // Additional catch block to ensure fullDataToDownloadLoader is reset
    // try {
    // } catch (error) {
    //   console.error("Error during file download:", error);
    //   toast.error("Something went wrong during the download...", { theme: "colored" });
    // } finally {
    //   setFullDataToDownloadLoader(false);
    //   sessionStorage.setItem("process", false);
    // }
  };

  const convertToText = (data) => {
    if (!data || data.length === 0) return '';
    
    const columns = Object.keys(data[0]);
    const colWidths = columns.map((col) =>
      Math.max(col.length, ...data.map((row) => (row[col] ? row[col].toString().length : 0)))
    );
  
    const header = columns.map((col, i) => col.padEnd(colWidths[i])).join('\t');
    const separator = colWidths.map((width) => ''.repeat(width)).join('\t');
  
    const rows = data.map((row) =>
      columns.map((col, i) => (row[col] ? row[col].toString().padEnd(colWidths[i]) : ' '.repeat(colWidths[i]))).join('\t')
    );
  
    return [header, separator, ...rows].join('\n');
  };

  const convertToTextWithoutHeader = (data) => {
    if (!data || data.length === 0) return '';
  
    const columns = Object.keys(data[0]);
    const colWidths = columns.map((col) =>
      Math.max(col.length, ...data.map((row) => (row[col] ? row[col].toString().length : 0)))
    );
  
    const separator = colWidths.map((width) => ''.repeat(width)).join('\t');
  
    const rows = data.map((row) =>
      columns.map((col, i) => (row[col] ? row[col].toString().padEnd(colWidths[i]) : ' '.repeat(colWidths[i]))).join('\t')
    );
  
    return [separator, ...rows].join('\n');
  };


  const sendEmail = async () => {
    const mailDataToSend = {
      "to": [userId],
      "subject": `${userId} Downloaded ${fileNameToSend} File`,
      "body": `<html>
                  <p>Dear User,</p>
                  <p>This is to confirm that ${userId} has downloaded the file ${fileNameToSend} from our system.</p>
                  <p>Thank you for using our services.</p>
                  <p>Sincerely,</p>
                  <p>The ICICIHFC</p>
                </html>`
    };

    try {
      const apiToFetch = `${apiBaseUrl}api/Email/SendEmail`;
      const filesResponse = await axios.post(apiToFetch, mailDataToSend, {
        withCredentials: true,
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${sessionStorage.getItem("token")}`
        },
      });

      if(filesResponse.headers['X-New-JWT-Token']){
            sessionStorage.setItem("token", filesResponse.headers['X-New-JWT-Token'])
           }

      if (filesResponse.status === 200) {
        // Email sent successfully
      } else {
        console.error("API ERROR", filesResponse)
      }
    } catch (error) {
       if(error.response.status === 401) {
          if(error.response.data === 'Unauthorized: Token is expired') {
            toast.error("Session expired", {theme: "colored"})
          } else {
            toast.error("Already open in another Tab", {theme : "colored"});
          }
          sessionStorage.clear(); setTimeout(() => {
            window.location.href = "/";
          }, 1000);
        }
      console.error("The API Error is", error);
    }
  };

  const userLogs = async () => {
    const mailDataToSend = {
      "username": userId,
      "action": "Download",
      "downloadUploadFile": fileNameToSend
    };

    try {
      const apiToFetch = `${apiBaseUrl}api/UsersLogs/UserAction`;
      const filesResponse = await axios.post(apiToFetch, mailDataToSend, {
        withCredentials: true,
        headers: {
          "Content-Type": "application/json",
           Authorization: `Bearer ${sessionStorage.getItem("token")}`
        },
      });

      if(filesResponse.headers['X-New-JWT-Token']){
            sessionStorage.setItem("token", filesResponse.headers['X-New-JWT-Token'])
           }

      if (filesResponse.status === 200) {
      } else {
        console.error("API ERROR", filesResponse);
      }
    } catch (error) {

       if(error.response.status === 401) {
          if(error.response.data === 'Unauthorized: Token is expired') {
            toast.error("Session expired", {theme: "colored"})
          } else {
            toast.error("Already open in another Tab", {theme : "colored"});
          }
          sessionStorage.clear(); setTimeout(() => {
            window.location.href = "/";
          }, 1000);
        }
      console.error("The API error", error);
    }
  };

  const debounce = (func, delay) => {
    let timeoutId;
    return (...args) => {
      if (timeoutId) clearTimeout(timeoutId);
      timeoutId = setTimeout(() => func(...args), delay);
    };
  };


   const debouncedSearchTextData = useCallback(debounce((page, column, searchText) => {
    handleSearchText(page, column, searchText);
  }, 1000), []);


    const handleAllTextSearch = (e) => {
    const searchValueText = e.target.value;
    console.log("search text", searchValueText);
    setSearchTextForFilter(searchValueText);
    if (searchValueText === '') {
      debouncedSearchTextData(1, dropdownSelectedColumn, '');
    } else {
      debouncedSearchTextData(1, dropdownSelectedColumn, searchValueText);
    }
  };

  const handleSearchText = async (newPage, column, searchText) => {
    setValueSearchText(searchText);
    setSelectedSearchColumn(column);
    setFile_modal_Loader(true);

    try {
      const urlForApi = `${apiBaseUrl}api/ReportModules/GetDataFromTableAfterFilter`;

      const filesResponse = await axios.post(urlForApi, {
        username: userId,
        filename: fileNameToSend,
        foldername: folderName,
        checkedColumnName: checkedColumns.length > 0 ? checkedColumns : ["*"],
        filterColumnName: column,
        pageSize: pageSize,
        pageNumber: newPage,
        startDate: startDateTable,
        endDate: endDateTable,
      }, { withCredentials: true ,
        headers: {
            Authorization: `Bearer ${sessionStorage.getItem("token")}`
        }
      });

      if(filesResponse.headers['X-New-JWT-Token']){
            sessionStorage.setItem("token", filesResponse.headers['X-New-JWT-Token'])
           }

      if (filesResponse.data === "You don't have access to this data") {
        setAccessGranted(false);
        setFile_modal_Loader(false);
      }
       else if (filesResponse.data === "No Data Found" || filesResponse.data.totalCount === 0) {
        setNoData(true);
        setAccessGranted(false);
        setFile_modal_Loader(false);
      } else {
        const pro = filesResponse.data.data;
        setPdata(pro);
        setNumRows(filesResponse.data.totalCount);
        setAccessGranted(true);
        setPage(newPage);
        setFile_modal_Loader(false);
      }
    } catch (error) {
      if (error.response && (error.response.status === 404 || error.response.status === 500)) {
        setNoData(true);
        setAccessGranted(false);
        setNoDataError(true);
      }
        if(error.response.status === 401) {
          if(error.response.data === 'Unauthorized: Token is expired') {
            toast.error("Session expired", {theme: "colored"})
          } else {
            toast.error("Already open in another Tab", {theme : "colored"});
          }
          sessionStorage.clear(); setTimeout(() => {
            window.location.href = "/";
          }, 1000);
        }


      console.error("Error fetching filter data:", error);
      setFile_modal_Loader(false);
    }
  };

  const handleChangeDropdown = (value, label) => {
    setSelectedItems('');
    setSelectedItems(label);
    setDropdownSelectedColumn(label.value);
  };

    const fetchMaxDate = async () => {
    try {
      const sortedDataResponse = await axios.get(`${apiBaseUrl}api/ReportModules/maxBusinessDate/${fileNameToSend}/${folderName}`, { withCredentials: true,
        headers: {
            Authorization: `Bearer ${sessionStorage.getItem("token")}`
        }

      });

      if(sortedDataResponse.headers['X-New-JWT-Token']){
            sessionStorage.setItem("token", sortedDataResponse.headers['X-New-JWT-Token'])
           }

      setDateFromFile(sortedDataResponse.data.substring(0, 10));
      setStartDate(sortedDataResponse.data.substring(0, 10));
      setEndDate(sortedDataResponse.data.substring(0, 10));
    } catch (error) {

      if(error.response.status === 401) {
          if(error.response.data === 'Unauthorized: Token is expired') {
            toast.error("Session expired", {theme: "colored"})
          } else {
            toast.error("Already open in another Tab", {theme : "colored"});
          }
          sessionStorage.clear(); setTimeout(() => {
            window.location.href = "/";
          }, 1000);
        }

      console.error("Error fetching sorted data:", error);
    }
  };

  let filterOption = (input, option) => 
    (option?.label ?? '').toLowerCase().includes(input.toLowerCase());

  let filterOptions = (input, option) => 
    (option?.label ?? '').toLowerCase().includes(input.toLowerCase());



  const fetchColumns = async () => {
    try {
      const response = await fetch(`${apiBaseUrl}api/ReportModules/GetFieldNamesAccordingToUser?username=${userId}&filename=${fileNameToSend}&foldername=${folderName}`,
        {
         headers: {
            Authorization: `Bearer ${sessionStorage.getItem("token")}`
        },
      }
     );

     if(response.headers['X-New-JWT-Token']){
            sessionStorage.setItem("token", response.headers['X-New-JWT-Token'])
           }

           if(!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
           }

      const data = await response.json();
      setColumns(data);

      const convertedArray = data.map(item => ({ value: item, label: item }));
      setColumnOPTIONS(convertedArray);
      setCheckedColumns(data);
    } catch (error) {
      console.error('Error fetching column names:', error);

      if(error.message.includes('401')) {
        if(error.response.data === 'Unauthorized: Token is expired') {
             toast.error("Session expired", {theme: "colored"})
        } else {
            toast.error("Already open in another Tab", {theme : "colored"});
          };
          sessionStorage.clear(); setTimeout(() => {
            window.location.href = "/";
          }, 1000);
        }
        else{

        }
      }
    };

     const handleCheckboxChange = (event) => {
    const { value, checked } = event.target;
    console.log("Checkbox value:", value);
    if (value === 'selectAll') {
      if (checked) {
        setCheckedColumns(columns);
      } else {
        setCheckedColumns([]);
      }
    } else {
      if (checked) {
        setCheckedColumns(prevState => [...prevState, value]);
      } else {
        setCheckedColumns(prevState => prevState.filter(column => column !== value));
      }
    }
  };

  const filteredColumns = searchTerm ? columns.filter(column => column.toLowerCase().includes(searchTerm.toLowerCase())) : columns;


    const fetchByColumnName = async (e, newPage) => {
    setFile_modal_Loader(true);

    if (valueSearchText.trim() !== '') {
      handleSearchText(newPage, selectedSearchColumn, valueSearchText);
    } else {

      try {
        const getContentInFilesApiUrl = `${apiBaseUrl}api/ReportModules/GetDataFromTableByColumnName`;

        const urlForApi = getContentInFilesApiUrl;

        const filesResponse = await axios.post(urlForApi, {
          username: userId,
          filename: e,
          foldername: folderName,
          checkedColumns: checkedColumns,
          pagesize: pageSize,
          pagenumber: newPage,
        }, 
        { withCredentials: true,
            headers: {
            Authorization: `Bearer ${sessionStorage.getItem("token")}`
        }
         });

         if(filesResponse.headers['X-New-JWT-Token']){
            sessionStorage.setItem("token", filesResponse.headers['X-New-JWT-Token'])
           }


        if (filesResponse.data === "You don't have access to this data") {
          setAccessGranted(false);
          setFile_modal_Loader(false);
        } else if (filesResponse.data === "No Data Found" || filesResponse.data.totalCount === 0) {
          setNoData(true);
          setAccessGranted(false);
          setFile_modal_Loader(false);
        } else {
          const pro = filesResponse.data.data;
          setPdata(pro);
          setSearchPdata(pro);
          setNumRows(filesResponse.data.totalCount);
          setAccessGranted(true);
          setPage(newPage);
          setFile_modal_Loader(false);
        }
      } catch (error) {
        if (error.response && (error.response.status === 404 || error.response.status === 500)) {
          setNoData(true);
          setAccessGranted(false);
          setNoDataError(true);
        }
        if(error.response.status === 401) {
          if(error.response.data === 'Unauthorized: Token is expired') {
            toast.error("Session expired", {theme: "colored"})
          } else {
            toast.error("Already open in another Tab", {theme : "colored"});
          }
          sessionStorage.clear(); setTimeout(() => {
            window.location.href = "/";
          }, 1000);
        }

        console.error("Error fetching files by column:", error);
        setFile_modal_Loader(false);
      }
    }
  };


  return (
        <>
 <Modal
      centered   //centered: Vertically centers the modal on the screen.
    //   open={modalOpen}  //open={modalOpen}: Controls whether the modal is visible. true shows it, false hides it.
    open={true}
      footer={null}  //Removes the default OK/Cancel buttons from the bottom of the modal.
      title={null}  //  Removes the default title header area from the top of the modal.
      width="95%"
      style={{ maxWidth: '1200px' }}
      closeIcon={fullDataToDownloadLoader ? false : true}  //Hides the close (X) icon when a file is downloading (fullDataToDownloadLoader === true) to avoid accidental closing.
      maskClosable={false}  //Prevents closing the modal by clicking outside it.
    //   onCancel={() => { setModalOpen(false); }}   //Callback to run when the modal is closed. It sets modalOpen to false.
    >
    <ToastContainer />
    <div className="modalContent">
      <div className="modalContentsModule">
        <div className="modalHeaderWrapper">
          <div className="modalHeaderContent">
            <div className='modalViewComponent'>
            {/* check */}
             
              <FormControl sx={{ minWidth: 200 }} size="small">
                  <InputLabel className="inputlabel">
                    {fileNameToSend}
                  </InputLabel>
                  <AntSelect
                    label={fileNameToSend}
                    open={isOpen}
                    onOpen={handleToggle}
                    onClose={handleToggle}
                    MenuProps={{ PaperProps: { style: { width: 200 } } }}
                    style={{ height: 32 }}
                  >
                    <TextField
                      placeholder="Select Column Name"
                      fullWidth
                      InputProps={{ style: { height: 25 } }}
                      onClick={(e) => e.stopPropagation()}
                      onChange={(e) => setSearchTerm(e.target.value)}
                      value={searchTerm}
                    />
                    <MenuItem className="fileModalCheckbox" onClick={(e) => e.stopPropagation()}>
                      <div onClick={(e) => e.stopPropagation()}>
                        <CheckboxComponent
                          columns={filteredColumns}
                          checkedColumns={checkedColumns}
                          handleCheckboxChange={handleCheckboxChange}
                          onClick={handleCheckboxClick}
                        />
                      </div>
                    </MenuItem>
                  </AntSelect>
                </FormControl>

               <FormControl className="selectColumnForm" size="small">
  <Select
    className="selectColumnDropdown"
    mode="single"
    showSearch
    placeholder="Click to Select Column"
    onChange={handleChangeDropdown}
    filterOption={filterOption}
    options={columnOPTIONS}
  />
</FormControl>
{/* *********************************************************************************************************** */}
<FormControl className="textSearchForm" size="small">
  <Input
    className="textSearchInput"
    sx = {{
      borderRadius: "0.4rem"
    }}
    placeholder="Enter text to search"
    onChange={handleAllTextSearch}
  />
</FormControl>


<FormControl className="dateRangeForm" size="small">
  <RangePicker
    className="bg-transparent"
    onChange={handleDateChange}
    disabledDate={disableDate}
  />
</FormControl>
</div>
<div>
                <p className="titleReport_date">Refresh on: {dateFromFile}</p>
                <p className="titleReport_date">Count: {numRows}</p>
              </div>
          </div>
        </div>
        <div className="headerContent"></div>
          {file_modal_Loader ? 
            <div className="loader-section">
              <ThreeDots height="200" width="150" radius="9" color="#4fa94d" ariaLabel="three-dots-loading" visible={true} />
              <p className="loader-text">Please Wait, Data is loading...</p>
            </div>
           :  
            <div className="tableContent">
              {accessGranted ? (
                <TableFile 
                data={pdata} 
                searchTextValue={valueSearchText} 
                SearchTextData={handleSearchText} 
                searchColumn={selectedSearchColumn} 
                endDateTable={endDateTable} />
              ) : (
                <div className="accessDeniedMessage">
                  {noData === true ? 
                    <p className="titleReport">{noDataError ? `NO Data Found...` : `Hmm...something seems to have gone wrong.`}</p>
                   : 
                    <p className="titleReport">You don't have access to this data.</p>
                  }
                </div>
              )}
            </div>
          }

          <div className="paginationNbutton">
            <div className="pagination-container">
              {numRows > 0 && (
                <div className="paginationNbuttonModal">
                  <div className="rows-per-page">
                    <div className="rows-per">
                    <div className="rows-text">Rows per Page: {pageSize}</div>
                    <div>
                    <Stack spacing={1}>
                      <Pagination count={Math.ceil(numRows / pageSize)} page={page} onChange={handleChange} />
                    </Stack>
                  </div>
                </div>
                </div>
                </div>
              )}
            </div>
            {userDownload === '1' && 
              <div className="btnSec">
                {fullDataToDownloadLoader ? 
                  <div className="downloading-section">
                    <div className = "downloading-sec">
                    <p>Downloading...</p>
                    <Box className="custom-box-style">
                      <LinearProgress />
                    </Box>
                    <div className="cancel-btn">
                      <IoMdClose fill="red" size={15} onClick={cancelDownload} />
                    </div>
                  </div>
                  </div>
                 :
                 <>
                    <Button
                      id="download-button"
                      aria-controls={anchorEl ? 'download-menu' : undefined}
                      aria-haspopup="true"
                      aria-expanded={anchorEl ? 'true' : undefined}
                      onClick={handleClick}
                      variant="contained"
                      endIcon={<ArrowDropDownIcon />}
                      style={{ color: 'black', backgroundColor: '#e5e5ea' }}
                    >
                      Download
                    </Button>
                        <Menu
                      id="download-menu"
                      anchorEl={anchorEl}
                      open={Boolean(anchorEl)}
                      onClose={handleClose}
                      MenuListProps={{
                        'aria-labelledby': 'download-button',
                      }}
                    >
                      <MenuItem onClick={(event) => handleSubMenuClick(event, 'currentPage')}>
                        Current Page Download
                      </MenuItem>
                      <Menu
                        id="current-page-menu"
                        anchorEl={subMenuAnchorEl}
                        open={currentSubMenu === 'currentPage' && Boolean(subMenuAnchorEl)}
                        onClose={handleClose}
                        MenuListProps={{
                          'aria-labelledby': 'current-page-menu',
                        }}
                      >
                        <MenuItem onClick={(event) => { event.preventDefault(); handleFileDownload('Ccsv'); }}> CSV</MenuItem>
                        <MenuItem onClick={(event) => { event.preventDefault(); handleFileDownload('Cxlsx'); }}> XLSX</MenuItem>
                        <MenuItem onClick={handleSubMenuClick2}>TEXT</MenuItem>
                        <Menu
                          id="text-menu"
                          anchorEl={subMenuAnchorEl2}
                          open={Boolean(subMenuAnchorEl2)}
                          onClose={handleClose}
                          MenuListProps={{
                            'aria-labelledby': 'text-menu',
                          }}
                        >
                          <MenuItem onClick={(event) => { event.preventDefault(); handleFileDownload('Chtxt'); }}>With Header</MenuItem>
                          <MenuItem onClick={(event) => { event.preventDefault(); handleFileDownload('Ctxt'); }}>Without Header</MenuItem>
                        </Menu>
                      </Menu>
                      <MenuItem onClick={(event) => handleSubMenuClick(event, 'fullFile')}>
                        {searchTextForFilter !== '' ? 'Filter Full Data Download' : 'Full File Download'}
                      </MenuItem>
                      <Menu
                        id="full-file-menu"
                        anchorEl={subMenuAnchorEl}
                        open={currentSubMenu === 'fullFile' && Boolean(subMenuAnchorEl)}
                        onClose={handleClose}
                        MenuListProps={{
                          'aria-labelledby': 'full-file-menu',
                        }}
                      >
                        <MenuItem onClick={(event) => { event.preventDefault(); handleFileDownload('Fcsv'); }}>CSV</MenuItem>
                        <MenuItem onClick={(event) => { event.preventDefault(); handleFileDownload('Fxlsx'); }}>XLSX</MenuItem>
                        <MenuItem onClick={handleSubMenuClick2}>TEXT</MenuItem>
                        <Menu
                          id="text-menu"
                          anchorEl={subMenuAnchorEl2}
                          open={Boolean(subMenuAnchorEl2)}
                          onClose={handleClose}
                          MenuListProps={{
                            'aria-labelledby': 'text-menu',
                          }}
                        >
                          <MenuItem onClick={(event) => { event.preventDefault(); handleFileDownload('Ftxt'); }}>with Header</MenuItem>
                          <MenuItem onClick={(event) => { event.preventDefault(); handleFileDownload('Fhtxt'); }}>without Header</MenuItem>
                        </Menu>
                      </Menu>
                    </Menu>
                     <Modal
            centered
            open={showConsentForm}
            footer={null}
            title={null}
            width={"auto"}
            closeIcon={!fullDataToDownloadLoader}
            maskClosable={false}
            onCancel={handleConsentFormClose}
          >
            <div className="consent-form">
              <h3>Terms and Conditions</h3>
              <p style={{ color: 'red' }}>
                1. It is the responsibility of the concerned Business Users to validate the downloaded data. <br />
                2. The data located in the specified folder is restricted exclusively to the team members associated with given permission. <br />
                3. Any data downloaded from the specified folder will result in a transfer of ownership to the downloading team. <br />
                4. Users need to make sure to download within given timelines. <br />
                5. Any SR raised for data sets, service timeline is 7 working days.
              </p>
              <div>
                <Input 
                type='checkbox' 
                id='agree' 
                checked={isChecked} 
                onChange={handleConsentBoxChange} 
                />&nbsp;
                <label htmlFor='agree'> I Agree </label>
              </div>
              <br />
              {isChecked && fileDownloadRequest && fileDownloadRequest.startsWith("F") && 
                <div>
                  Rows Per Sheet:
                  <Row>
                    <Col span={12}>
                      <Slider min={1} max={numRows} onChange={onChange} value={typeof inputValue === 'number' ? inputValue : 0} />
                    </Col>
                    <Col span={4}>
                      <InputNumber 
                      min={1} 
                      max={numRows}
                      onChange={onChange}
                      value={typeof inputValue === 'number' ? inputValue : 0 }  
                      />
                    </Col>
                    <Col span={4}>
                      <InputNumber 
                      min={1} 
                      max={numRows}
                      style ={{margin: '0 16px'}}
                      value={inputValue} 
                      onChange={onChange}
                      />
                    </Col>
                  </Row>
                </div>}
              <Button 
              variant="outlined" 
              onClick={handleConsentFormSubmit} 
              disabled={!isChecked || isSubmitting} 
              style={{ width: '75px' }}
              >
                {isSubmitting ? "Submitting..." : "OK"}
              </Button>&nbsp;&nbsp;
              <Button 
              variant="outlined" 
              onClick={handleConsentFormClose} 
              disabled={isSubmitting} 
              style={{ width: '75px' }}
              >
                Close
              </Button>
            </div>
          </Modal>
          </> }
        </div>
}
</div>
</div>
</div>
      </Modal>
    </>
  );
};

export default FileModal1;



.modalContent {
    display: flex;
    flex-direction: column;
    gap: 1vh;
    align-self: center;
    justify-content: center;
    /* padding: 1rem; Added padding for breathing room on smaller screens */
  }


    .modalHeaderWrapper {
  display: flex;
  padding-bottom: 20px;
}

.modalHeaderContent {
  display: flex;
  justify-content: space-between; /* important */
  align-items: center;
  flex-wrap: wrap; /* allows responsiveness */
  gap: 1rem; /* gives spacing between items */
  width: 100%;
  padding: 0 1rem;
}

 .modalViewComponent {
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 12px;
    margin-right: 12px;
  }

  .inputlabel {
    height : 32px;
    padding-right: 10px;
    padding-bottom: 10px;
    font-size: 12px;
  }

  .selectColumnForm {
  width: 150px;
  height: 32px;
}


.selectColumnDropdown {
  width: 150px;
  height: 32px;
  font-size: 12px;
  border-radius: 0.4rem;
  border-bottom-right-radius: 0rem;
  border-top-right-radius: 0rem;
}

.textSearchForm {
  min-width: 150px;
  height: 32px;
}

.textSearchInput {
  width: 150px;
  height: 32px;
}

.dateRangeForm {
  min-width: 150px;
  height: 32px;
}

.titleReport_date {
  font-size: 1rem;
  margin: 0;
}

.headerContent {
    display: flex;
    flex-direction: row;
    justify-content: space-between;
    padding-right: 1%;
    padding-left: 1%;
    width: 98%;
  }

  .loader-section {
  display: flex;
  flex-direction: column;
  align-items: center;
  margin-top: 2rem;
}

.loader-text {
  align-self: center;
  /* font-size: 16px;
  color: #333;
  margin-top: 1rem; */
}

 .tableContent {
    max-height: 46vh;
    margin-left: 1%;
    margin-top: -2px;
    margin-bottom: 10px;
  }

   .modalContentsModule
  {
    color: #36556b;
    font-family: Arial, Helvetica, sans-serif;
    font-size: 1rem !important;
    font-style: normal;
    font-weight: 600 !important;
    line-height: normal;
    margin-left: 12px;
  }

  .titleReport {
    font-size: 15px;
    margin-left: 2%;
    margin-top: 2%;
  }

   .modalContentsModule .titleReport
  {
    color: #36556b;
    font-family: Arial, Helvetica, sans-serif;
    font-size: 1.5rem;
    font-style: normal;
    font-weight: 700;
    line-height: normal;
    margin-right: 24px;
  }

  .paginationNbutton {
    display: flex;
    align-items: center;
    width: 1150px;
    margin-bottom: 32px;
    height: 51px;
    margin-left: 54px;
  }

  .pagination-container{
    display: flex;
    gap: 1vh;
    width: 70%;
  }

   .paginationNbuttonModal {
    display: flex;
    gap: 4vw;
    position: relative;
  }

  .rows-per-page{
    display: flex;
    gap: 1vh;
    width: 100%;
  }

  .rows-per{
    display: flex;
    align-items: center;
  }

  .rows-text{
    margin-left: 1vw;
  }

  .btnSec {
    width: 30%;
    float: right;
    position: relative;
    display: flex;
    margin-right: 38px;
    justify-content: end;
  }

 .btnSec.Dropdown {
    color: #365568;
    border-radius: 1rem;
    box-sizing: border-box;
    float: right;
    position: relative;
  }

  .downloading-section{
    width: 100%;
  }

  .downloading-sec {
    display: flex;
    gap: 15px;
  }

  .custom-box-style {
  width: 35%;
  height: 25px;
  position: relative;
  align-self: center;
  padding-top: 5px;
}

.cancel-btn{
  padding-top: 5px;
}

  @media (max-width: 1000px) {
    .btnSec select {
      width: 6vw;
      height: 4vh;
      color: #36556B;
      border: 1px solid #36556B;
      background-color: white;
      border-radius: 5rem;
      padding: 1vh 0vw 2vw -1vh; /* Top: 1vh, Right: 0, Bottom: 2vw, Left: 0.5vw */
      font-size: 0.7rem;
    }
  }



///////////////////latest original
.modalContent {
    display: flex;
    flex-direction: column;
    gap: 1vh;
    align-self: center;
    justify-content: center;
    /* padding: 1rem; Added padding for breathing room on smaller screens */
  }


.rs-dropdown-menu {
  position: relative;
}

.rs-dropdown-menu .rs-dropdown-menu {
  right: auto;
  left : 100%;
  position: absolute;
  top: 0;
  right: 0;
}

.paginationNbuttonModal {
    display: flex;
    gap: 4vw;
    position: relative;
  }

  .pagination {
    width : 85%;
    float: left;
    position: relative;
    display: flex;
    margin-top: 3vh;
    margin-left: 0vw;
  }

  .btnSec {
    width: 30%;
    float: right;
    position: relative;
    display: flex;
    margin-right: 38px;
    justify-content: end;
  }

  .cancel_fileModal_btn {
    color: #36556B;
    border-radius: 0.4rem;
    box-sizing: border-box;
    float: right;
    position: relative;
    padding: 6px 20px 6px 20px;
    margin: auto;
  }

  .cancel_fileModal_btn:hover {
      background: #e4e4f1e4;
      color: #36556B;
  }

   .btnSec.Dropdown {
    color: #365568;
    border-radius: 1rem;
    box-sizing: border-box;
    float: right;
    position: relative;
  }

  .ant-pagination .ant-pagination-item:not(.ant-pagination-item-active):hover {
    transition: all 0.2s;
  }

  .ant-pagination .ant-pagination-item-active {
    background-color: #4968ff;
    color: white !important;
    font-weight: 400;
    border-color: #4968ff;
  }

  .ant-pagination .ant-pagination-item-active a {
    color: white !important;
  }

  .headerContent {
    display: flex;
    flex-direction: row;
    justify-content: space-between;
    padding-right: 1%;
    padding-left: 1%;
    width: 98%;
  }

  .titleReport_date {
  font-size: 1rem;
  margin: 0;
}

.modalSelect_search{
  width: 40%;
  display: flex;
  flex-direction: row;
  gap: 5px;
}

:where(.css-dev-only-do-not-override-1vr7spz).ant-input {
    border-radius: 0px;
    border-bottom-right-radius: 0.4rem;
    border-top-right-radius: 0.4rem;
    border: 1px solid #E7E7E7;
  }

   .endhead {
    margin-top: 35px;
    justify-content: center;
    display: flex;
  }

  .customSelect {
    appearance: none;
    -webkit-appearance: none;
    -moz-appearance: none;
    /* background: url('../../../../Assets/Union\ 2.svg') no-repeat calc(100% - 0.9vw) center; */
    padding-right: 1vw;
    border: 1px solid #ccc;
    border-radius: 4px;
    padding-top: -1vh;
    font-size: 1rem;
  }


    .search-inputforModal {
    background: #FFFFFF;
    height: 5vh;
    position: relative;
    border: 1px solid #365568;
    width: 12vw;
    border-radius: 32px;
    margin-right: 1vw;
    padding-left: 0.5vw;
  }


    .requestAccessBtnforModal {
    margin-left: 1vw;
    width: 10vw;
    height: 5vh;
    background: linear-gradient(180deg, #F8A716 0%, #E75126 100%);
    border-radius: 32px;
    border: none;
    color: #FFFFFF;
    font-family: Arial;
    font-size: 1.9vh;
    line-height: normal;
    font-weight: 400;
    text-align: center;
    cursor: pointer;
    box-sizing: border-box;
  }

    .tableContent {
    max-height: 46vh;
    margin-left: 1%;
    margin-top: -2px;
    margin-bottom: 10px;
  }


  @media (max-width: 1000px) {
    .btnSec select {
      width: 6vw;
      height: 4vh;
      color: #36556B;
      border: 1px solid #36556B;
      background-color: white;
      border-radius: 5rem;
      padding: 1vh 0vw 2vw -1vh; /* Top: 1vh, Right: 0, Bottom: 2vw, Left: 0.5vw */
      padding-left: 0.5vw;
      font-size: 0.7rem;
    }
  }

    :where(.css-1vr7spz).ant-select-single .ant-select-selector {
      border-radius: 0rem !important;
    }


      .filemodal_header_noclose.modal-header, .filemodal_header.modal-header {
    display: flex;
    position: relative;
    height: 60px !important;
    border-bottom: none !important;
  }

  .filemodal_header_noclose.modal-header {
    width: 100%;
    text-wrap: nowrap;
  }

   .modal-header .btn-close {
    margin-top: -11px;
  }

  .modal-dialog-centered {
    display: flex;
    justify-content: center;
    align-items: center;
  }

  .multiselect {
    width: 100%;
  }

   .ant-collapse-header {
    position: relative;
  }

   .modalViewComponent {
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 12px;
    margin-right: 12px;
  }

   .fileModalCheckbox .modelCheckboxes input[type="checkbox"] {
    height: 14px; /* Increased height */
    width: 14px;
    margin-right: 4px; /* Added right margin */
  }

   .modalContentsModule .titleReport
  {
    color: #36556b;
    font-family: Arial, Helvetica, sans-serif;
    font-size: 1.5rem;
    font-style: normal;
    font-weight: 700;
    line-height: normal;
    margin-right: 24px;
  }



.modalHeaderContent {
  display: flex;
  justify-content: space-between; /* important */
  align-items: center;
  flex-wrap: wrap; /* allows responsiveness */
  gap: 1rem; /* gives spacing between items */
  width: 100%;
  padding: 0 1rem;
}


.modalContentsModule
  {
    color: #36556b;
    font-family: Arial, Helvetica, sans-serif;
    font-size: 1rem !important;
    font-style: normal;
    font-weight: 600 !important;
    line-height: normal;
    margin-left: 12px;
  }

  .fileModalCheckbox {
    background: none !important;
  }

  .paginationNbutton {
    display: flex;
    align-items: center;
    width: 1150px;
    margin-bottom: 32px;
    height: 51px;
    margin-left: 54px;
  }

  .paginationNbuttons {
    display: flex;
    align-items: center;
    width: 1150px;
    margin-bottom: 32px;
    height: 51px;
    margin-left: 54px;
  }

  #download-button {
    color: white;
    background: #006A71;
  }


   .modalHeaderWrapper {
  display: flex;
  padding-bottom: 20px;
}

  .inputlabel {
    height : 32px;
    padding-right: 10px;
    padding-bottom: 10px;
    font-size: 12px;
  }

  .selectColumnForm {
  width: 150px;
  height: 32px;
}


.selectColumnDropdown {
  width: 150px;
  height: 32px;
  font-size: 12px;
  border-radius: 0.4rem;
  border-bottom-right-radius: 0rem;
  border-top-right-radius: 0rem;
}

.textSearchForm {
  min-width: 150px;
  height: 32px;
}

.textSearchInput {
  width: 150px;
  height: 32px;
}

.dateRangeForm {
  min-width: 150px;
  height: 32px;
}





  .loader-section {
  display: flex;
  flex-direction: column;
  align-items: center;
  margin-top: 2rem;
}

.loader-text {
  align-self: center;
  /* font-size: 16px;
  color: #333;
  margin-top: 1rem; */
}

 .tableContent {
    max-height: 46vh;
    margin-left: 1%;
    margin-top: -2px;
    margin-bottom: 10px;
  }

   

  .titleReport {
    font-size: 15px;
    margin-left: 2%;
    margin-top: 2%;
  }

  


  

  .pagination-container{
    display: flex;
    gap: 1vh;
    width: 70%;
  }

  .rows-per-page{
    display: flex;
    gap: 1vh;
    width: 100%;
  }

  .rows-per{
    display: flex;
    align-items: center;
  }

  .rows-text{
    margin-left: 1vw;
  }


  .downloading-section{
    width: 100%;
  }

  .downloading-sec {
    display: flex;
    gap: 15px;
  }

  .custom-box-style {
  width: 35%;
  height: 25px;
  position: relative;
  align-self: center;
  padding-top: 5px;
}

.cancel-btn{
  padding-top: 5px;
}

@media (max-width: 1000px) {
    .btnSec select {
      width: 6vw;
      height: 4vh;
      color: #36556B;
      border: 1px solid #36556B;
      background-color: white;
      border-radius: 5rem;
      padding: 1vh 0vw 2vw -1vh; /* Top: 1vh, Right: 0, Bottom: 2vw, Left: 0.5vw */
      padding-left: 0.5vw;
      font-size: 0.7rem;
    }
  }


@media (min-width: 1921px) {
  
}



//////mediauery

@media (max-width: 1440px) {
  .modalContent {
    font-size: 1.1rem;
    padding: 0.9rem;
  }
  
   .modalContentsModule {
    font-size: 0.95rem !important;
    margin-left: 10px;
  }
  .modalContentsModule .titleReport {
    font-size: 1.4rem;
  }

  .modalHeaderWrapper {
    padding-bottom: 18px;
    display: flex;
  }

  .modalHeaderContent {
    gap: 0.8rem;
    padding: 0 0.8rem;
  }

   .modalViewComponent {
    gap: 10px;
    display: flex;
    margin-right: 10px;
  }

  #formControl1{
    min-width: 220px;
  }

  .inputlabel {
    height : 28px;
    padding-right: 10px;
    padding-bottom: 10px;
    font-size: 12px;
  }

  .AntSelect1 {
  height: 38px;
}

}

/* 1280px laptops */
@media (max-width: 1280px) {
  .modalContent {
    font-size: 1rem;
    padding: 0.85rem;
  }

    .modalContentsModule {
    font-size: 0.9rem !important;
    margin-left: 8px;
  }
  .modalContentsModule .titleReport {
    font-size: 1.3rem;
  }

  .modalHeaderWrapper {
    padding-bottom: 16px;
    display: flex;
  }

  .modalHeaderContent {
    gap: 0.7rem;
    padding: 0 0.7rem;
  }

   .modalViewComponent {
    gap: 10px;
    margin-right: 8px;
    display: flex;
  }

  #formControl1{
    min-width: 200px;
  }

  .inputlabel {
    height : 26px;
    padding-right: 8px;
    padding-bottom: 8px;
    font-size: 10px;
  }

   .AntSelect1 {
  height: 36px;
}
}

/* 1024px tablets */
@media (max-width: 1024px) {
  .modalContent {
    font-size: 0.95rem;
    padding: 0.8rem;
  }

   .modalContentsModule .titleReport {
    font-size: 1.2rem;
  }

  .modalHeaderWrapper {
    padding-bottom: 14px;
    display: flex;
  }

  .modalHeaderContent {
    gap: 0.6rem;
    padding: 0 0.6rem;
  }

  .modalViewComponent {
    gap: 8px;
    margin-right: 6px;
    display: flex;
  }
  #formControl1{
    min-width: 180px;
  }

  .inputlabel {
    height : 24px;
    padding-right: 8px;
    padding-bottom: 8px;
    font-size: 10px;
  }

  .AntSelect1 {
  height: 34px;
}
}

/* 768px tablets portrait */
@media (max-width: 768px) {
  .modalContent {
    font-size: 0.9rem;
    padding: 0.75rem;
    gap: 1.5vh;
  }

   .modalContentsModule .titleReport {
    font-size: 1.1rem;
    margin-right: 16px;
  }

  .modalHeaderWrapper {
    padding-bottom: 12px;
    display: flex;
  }

  .modalHeaderContent {
    gap: 0.5rem;
    padding: 0 0.5rem;
  }

  .modalViewComponent {
    align-items: flex-start;
    gap: 8px;
    margin-right: 0;
    display: flex;
  }

#formControl1{
    min-width: 160px;
  }

  .inputlabel {
    height : 22px;
    padding-right: 6px;
    padding-bottom: 6px;
    font-size: 8px;
  }

  .AntSelect1 {
  height: 32px;
}
}

/* 667px large phones */
@media (max-width: 667px) {
  .modalContent {
    font-size: 0.85rem;
    padding: 0.7rem;
    text-align: center;
  }

  .modalContentsModule .titleReport {
    font-size: 1rem;
    margin-right: 10px;
  }

  .modalHeaderWrapper {
    padding-bottom: 10px;
    display: flex;
  }

  .modalHeaderContent {
    gap: 0.4rem;
    padding: 0 0.4rem;
  }

   .modalViewComponent {
    gap: 6px;
  }

  #formControl1{
    min-width: 160px;
  }

  .inputlabel {
    height : 20px;
    padding-right: 6px;
    padding-bottom: 6px;
    font-size: 8px;
  }

  .AntSelect1 {
  height: 30px;
}
}

/* 414px375px phones */
@media (max-width: 414px) {
  .modalContent {
    font-size: 0.8rem;
    padding: 0.6rem;
  }

    .modalContentsModule {
    margin-left: 6px;
  }
  .modalContentsModule .titleReport {
    font-size: 1rem;
    margin-right: 10px;
  }

  .modalHeaderWrapper {
    padding-bottom: 8px;
    display: flex;
  }

  .modalHeaderContent {
    gap: 0.3rem;
    padding: 0 0.3rem;
  }

  .modalViewComponent {
    gap: 5px;
    padding-left: 4px;
  }
#formControl1{
    min-width: 140px;
  }

  .inputlabel {
    height : 18px;
    padding-right: 6px;
    padding-bottom: 6px;
    font-size: 8px;
  }

  .AntSelect1 {
  height: 28px;
}
}

/* 320px very small devices */
@media (max-width: 320px) {
  .modalContent {
    font-size: 0.75rem;
    padding: 0.5rem;
    gap: 1vh;
  }

  .modalContentsModule .titleReport {
    font-size: 0.95rem;
    margin-right: 6px;
  }

  .modalHeaderWrapper {

    padding-bottom: 6px;
    display: flex;
  }

  .modalHeaderContent {
    gap: 0.25rem;
    padding: 0 0.25rem;
  }

  .modalViewComponent {
    gap: 4px;
    font-size: 0.9rem;
  }

  #formControl1{
    min-width: 120px;
  }

  .inputlabel {
    height : 16px;
    padding-right: 4px;
    padding-bottom: 4px;
    font-size: 6px;
  }
  .AntSelect1 {
  height: 26px;
}
}

